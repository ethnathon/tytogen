#if ($umlUtils.shouldOutput($service))
<?xml version="1.0" encoding="$xmlEncoding"?>
<!-- Generated by andromda-webservice cartridge (wsdl/wrapped-wsdl.vsl) do not edit! -->
#parse("templates/webservice/Globals.vm")
<wsdl:definitions
    name="$service.qName"
    targetNamespace="$service.namespace"
    xmlns:${service.namespacePrefix}="$service.namespace"
    xmlns:wsdl="$wsdlNamespace"
    xmlns:wsdlsoap="$wsdlSoapNamespace"
    xmlns:xs="$xmlSchemaNamespace">

    <!-- WSDL Types -->
    <wsdl:types>
        <xs:schema attributeFormDefault="$service.package.attributeFormDefault.toLowerCase()" elementFormDefault="$service.package.elementFormDefault.toLowerCase()"
##        <xs:schema attributeFormDefault="$service.package.attributeFormDefault.toLowerCase()" elementFormDefault="$service.package.elementFormDefault.toLowerCase()"
                    targetNamespace="$service.namespace"
                    xmlns:${service.namespacePrefix}="$service.namespace"
                    xmlns="$xmlSchemaNamespace">
#foreach ($operation in $service.allowedOperations)
            <xs:element name="$operation.name">
#if ($stringUtils.isNotBlank($operation.getDocumentation("", 9999, false)))
                <xs:annotation>
                    <xs:documentation>
$stringUtils.replaceChars($operation.getDocumentation("                        ", 64, false), "\"'&<>", "")
                    </xs:documentation>
                </xs:annotation>
#end
#if (!$operation.arguments.empty)
                <xs:complexType>
                    <xs:sequence>
#foreach ($argument in $operation.arguments)
                        <xs:element name="$argument.name" type="$argument.type.schemaType" nillable="$argument.nillable">
#if ($stringUtils.isNotBlank($argument.getDocumentation("", 9999, false)))
                            <xs:annotation>
                                <xs:documentation>
$stringUtils.replaceChars($argument.getDocumentation("                                    ", 64, false), "\"'&<>", "")
                                </xs:documentation>
                            </xs:annotation>
#end
                        </xs:element>
#end
                    </xs:sequence>
                </xs:complexType>
#else
                <xs:complexType/>
#end
            </xs:element>
            <xs:element name="${operation.name}Response">
#if ($operation.returnTypePresent)
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="${operation.name}Return" type="$operation.returnType.schemaType"/>
                    </xs:sequence>
                </xs:complexType>
#else
                <xs:complexType/>
#end
            </xs:element>
#end
#foreach($exception in $service.allowedOperationExceptions)
            <xs:element name="${exception.name}" nillable="true" type="${exception.namespacePrefix}:${exception.qName}"/>
#end
#if (!$service.typeMappingElements.empty)

            <!-- Service TypeMapping elements -->
#end
#foreach ($typeMapping in $service.typeMappingElements)
## By default set the type as the typeMapping itself,
## however if it has a type, use that instead
#set ($type = $typeMapping)
#if ($typeMapping.type)
#set ($type = $typeMapping.type)
#end
## Handle any type mappings that happen to be associationEnds
#set ($arrayItemName = $stringUtils.uncapitalize($type.getSchemaType(false, false)))
#if ($typeMapping.many)
            <xs:complexType name="$type.wsdlArrayName">
                <xs:sequence>
                    <xs:element name="$arrayItemName" minOccurs="0" maxOccurs="unbounded" form="qualified" type="${type.namespacePrefix}:${type.qName}" />
                </xs:sequence>
            </xs:complexType>
#end
#if ($type.arrayType)
            <xs:complexType name="$type.getSchemaType(false, true)">
                <xs:sequence>
                    <xs:element name="$arrayItemName" minOccurs="0" maxOccurs="unbounded" form="qualified" type="$type.getSchemaType(true, false)" />
                </xs:sequence>
            </xs:complexType>
#else
#* *##if ($type.enumeration)
#*     *##foreach ($literal in $type.literals)
#*         *##if (!$stringUtils.isBlank($literal.type.schemaType))#set ($enumType = $literal.type.schemaType)#end
#*     *##end
#if ($stringUtils.isBlank($type.qName))#set ($typeName = ${type.name})#else#set ($typeName = $type.qName)#end
            <xs:simpleType name="${typeName}">
#if ($stringUtils.isNotBlank($type.getDocumentation("", 9999, false)))
                <xs:annotation>
                    <xs:documentation>
$stringUtils.replaceChars($type.getDocumentation("                        ", 64, false), "\"'&<>", "")
                    </xs:documentation>
                </xs:annotation>
#end
#if ($stringUtils.isBlank($enumType))#set ($enumType = "xs:string")#end
                <xs:restriction base="$enumType">
#*     *##foreach ($literal in $type.literals)
                    <xs:enumeration value="${escapeUtils.escapeXml($literal.enumerationValue.replaceAll('"', ''))}">
#if ($stringUtils.isNotBlank($literal.getDocumentation("", 9999, false)))
                        <xs:annotation>
                            <xs:documentation>
$stringUtils.replaceChars($literal.getDocumentation("                                ", 64, false), "\"'&<>", "")
                            </xs:documentation>
                        </xs:annotation>
#end
                    </xs:enumeration>
#*     *##end
                </xs:restriction>
            </xs:simpleType>
#* *##else
            <xs:complexType name="$type.qName">
#if ($stringUtils.isNotBlank($type.getDocumentation("", 9999, false)))
                <xs:annotation>
                    <xs:documentation>
$stringUtils.replaceChars($type.getDocumentation("                        ", 64, false), "\"'&<>", "")
                    </xs:documentation>
                </xs:annotation>
#end
#set ($extensionRequired = $type.generalization && !$extensionInheritanceDisabled)
#*     *##if ($extensionRequired)
                <xs:complexContent>
                <xs:extension base="${type.generalization.namespacePrefix}:$type.generalization.qName">
#*     *##end
#*     *##set ($attributes = $type.getAttributes($extensionInheritanceDisabled))
#*     *##set ($otherEnds = $type.getNavigableConnectingEnds($extensionInheritanceDisabled))
#*     *##if (!$attributes.empty || !$otherEnds.empty)
                <xs:all>
#*     *##foreach ($attribute in $attributes)
                    <xs:element name="$attribute.name" nillable="$attribute.nillable" type="$attribute.type.schemaType">
#if ($stringUtils.isNotBlank($attribute.getDocumentation("", 9999, false)))
                        <xs:annotation>
                            <xs:documentation>
$stringUtils.replaceChars($attribute.getDocumentation("                                ", 64, false), "\"'&<>", "")
                            </xs:documentation>
                        </xs:annotation>
#end
                    </xs:element>
#*     *##end
#*     *##foreach ($otherEnd in $otherEnds)
#*         *##set ($type = $otherEnd.type)
#*         *##if ($otherEnd.many)
#*             *##set ($schemaType = "${type.namespacePrefix}:${type.wsdlArrayName}")
#*         *##else
#*         *##set ($schemaType = "${type.namespacePrefix}:${type.qName}")
#*     *##end
                    <xs:element name="$otherEnd.name" nillable="$otherEnd.nillable" type="${schemaType}">
#if ($stringUtils.isNotBlank($otherEnd.getDocumentation("", 9999, false)))
                        <xs:annotation>
                            <xs:documentation>
$stringUtils.replaceChars($otherEnd.getDocumentation("                                ", 64, false), "\"'&<>", "")
                            </xs:documentation>
                        </xs:annotation>
#end
                    </xs:element>
#end
                </xs:all>
#end
#*     *##if ($extensionRequired)
                </xs:extension>
                </xs:complexContent>
#*     *##end
            </xs:complexType>
#end
#end
#end
        </xs:schema>
    </wsdl:types>

    <!-- Messages -->
#foreach ($operation in $service.allowedOperations)
    <wsdl:message name="${operation.name}Request">
        <wsdl:part element="${service.namespacePrefix}:${operation.name}" name="parameters"/>
    </wsdl:message>
    <wsdl:message name="${operation.name}Response">
        <wsdl:part element="${service.namespacePrefix}:${operation.name}Response" name="parameters"/>
    </wsdl:message>
#end
#foreach($exception in $service.allowedOperationExceptions)
    <wsdl:message name="${exception.name}">
        <wsdl:part element="${service.namespacePrefix}:${exception.name}" name="fault"/>
    </wsdl:message>
#end

    <!-- Port Type -->
    <wsdl:portType name="${service.qName}PortType">
#foreach ($operation in $service.allowedOperations)
        <wsdl:operation name="$operation.name">
#if ($stringUtils.isNotBlank($operation.getDocumentation("", 9999, false)))
            <wsdl:documentation>
$stringUtils.replaceChars($operation.getDocumentation("                ", 64, false), "\"'&<>", "")
            </wsdl:documentation>
#end
            <wsdl:input message="${service.namespacePrefix}:${operation.name}Request"
                        name="${operation.name}Request"/>
            <wsdl:output message="${service.namespacePrefix}:${operation.name}Response"
                         name="${operation.name}Response"/>
#foreach($exception in $operation.exceptions)
            <wsdl:fault message="${service.namespacePrefix}:${exception.name}"
                        name="${exception.name}" />
#end
        </wsdl:operation>
#end
    </wsdl:portType>

#set ($serviceBindingName = "${service.qName}SoapBinding")
    <!-- WSDL Binding -->
    <wsdl:binding name="$serviceBindingName" type="${service.namespacePrefix}:${service.qName}PortType">
        <wsdlsoap:binding style="document" transport="$documentStyleTransportNamespace"/>
#foreach ($operation in $service.allowedOperations)
        <wsdl:operation name="$operation.name">
            <wsdlsoap:operation soapAction="$operation.name" style="document"/>
            <wsdl:input name="${operation.name}Request">
                <wsdlsoap:body use="literal"/>
            </wsdl:input>
            <wsdl:output name="${operation.name}Response">
                <wsdlsoap:body use="literal"/>
            </wsdl:output>
#foreach($exception in $operation.exceptions)
            <wsdl:fault name="${exception.name}">
                <wsdlsoap:fault name="${exception.name}" use="literal"/>
            </wsdl:fault>
#end
        </wsdl:operation>
#end
    </wsdl:binding>

    <!-- Service Definition -->
    <wsdl:service name="$service.qName">
#if ($stringUtils.isNotBlank($service.getDocumentation("", 9999, false)))
        <wsdl:documentation>
$service.getDocumentation("            ", 64, false)
        </wsdl:documentation>
#end
        <wsdl:port binding="${service.namespacePrefix}:${serviceBindingName}" name="$service.qName">
            <wsdlsoap:address location="${wsdlSoapAddress}/${service.qName}"/>
        </wsdl:port>
    </wsdl:service>

</wsdl:definitions>
#end
